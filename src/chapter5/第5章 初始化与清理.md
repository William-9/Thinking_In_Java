# 第5章 初始化与清理

## 5.1用构造器确保初始化

​	构造器是一种特殊类型的方法，因为它没有返回值，这与返回值为空（void）明显不同。对于空返回值，尽管方法本身不会自动返回什么，但仍可选择让它返回别的东西。



## 5.2方法重载

```java
public class Tree {
    int height;
    Tree() {
        System.out.println("Planting a seeding");
        height = 0;
    }
    Tree(int initialHeight) {
        height = initialHeight;
        System.out.println("Creating new Tree that is" + height + " feet tall");
    }
    void info() {
        System.out.println("Tree is " + height + " feet tall");
    }
    void info(String s) {
        System.out.println(s + ":Tree is " + height + " feet tall");
    }
}
public class Overloading {
    public static void main(String[] args) {
        for (int i = 0; i < 5; i++) {
            Tree t = new Tree(i);
            t.info();
            t.info("overloaded method");
        }
        new Tree();
    }
}
//output
Creating new Tree that is 0 feet tall
Tree is 0 feet tall
overloaded method:Tree is 0 feet tall
Creating new Tree that is 1 feet tall
Tree is 1 feet tall
overloaded method:Tree is 1 feet tall
Creating new Tree that is 2 feet tall
Tree is 2 feet tall
overloaded method:Tree is 2 feet tall
Creating new Tree that is 3 feet tall
Tree is 3 feet tall
overloaded method:Tree is 3 feet tall
Creating new Tree that is 4 feet tall
Tree is 4 feet tall
overloaded method:Tree is 4 feet tall
Planting a seeding

```



### 5.2.2 涉及基本类型的重载

①如果传入类型小于方法中声明的形式参数类型，实际数据类型就会被提升。

②char型略有不同，如果无法找到恰好接收char型参数的方法，就会把char型直接提升至int型。

### 5.2.3 以返回值区分重载方法

①根据返回值来区分重载方法是行不通的。

```java
void f(){}
int f(){}

f();
```

比如上面的例子，编译器就无法判断调用哪个方法。

## 5.3 默认构造器

①默认构造器是没有形式参数的构造器，在没有定构造器时，编译器会自动定义一个，但是如果自定义了一个构造器（无论是否有参数），编译器都不再自动创建默认构造器。

## 5.4 this关键字

```java
public class Person {
    public void eat(Apple apple){
        Apple peeled = apple.getPeeled();
        System.out.println("Yummy");
    }
}

public class Peeler {
    static Apple peel (Apple apple){
        return apple;
    }
}

public class Apple {
    Apple getPeeled(){
        return Peeler.peel(this);
    }
}

public class PassingThis {
    public static void main(String[] args) {
        new Person().eat(new Apple());
    }
}

//output
Yummy
```



-------------------------------------------------------------------2018 10.31 上午08:33---------------------------------------------------------------



### 5.4.1 在构造器中调用构造器

```java
public class Flower {
    int petalCount = 0;
    String s = "initial value";
    Flower(int petals) {
        petalCount = petals;
        System.out.println("Constructor w/ int arg only, petalCount= "
                + petalCount);
    }
    Flower(String ss) {
        System.out.println("Constructor w/ String arg only, s = " + ss);
        s = ss;
    }
    Flower(String s, int petals) {
        this(petals);
//!    this(s); // Can't call two!
        this.s = s; // Another use of "this"
        System.out.println("String & int args");
    }
    Flower() {
        this("hi", 47);
        System.out.println("default constructor (no args)");
    }
    void printPetalCount() {
//! this(11); // Not inside non-constructor!
        System.out.println("petalCount = " + petalCount + " s = "+ s);
    }
    public static void main(String[] args) {
        Flower x = new Flower();
        x.printPetalCount();
    }
}
//output
Constructor w/ int arg only, petalCount= 47
String & int args
default constructor (no args)
petalCount = 47 s = hi
```



### 5.4.2 static的含义

①static方法就像是全局方法，虽然Java禁止全局方法，但是static方法的实现方式就相当于全局方法，也称为类方法。

## 5.5 清理：终结处理和垃圾回收

①Java允许在类中定义一个名为finalize（）的方法。它的工作原理假定是这样的：一旦垃圾回收器准备好释放对象占用的存储空间时，将首先调用器finalize（）方法，下一次执行垃圾回收的时候，才会真正回收对象占用的内存。

### 5.5.1 finalize（）的用途何在

### 5.5.2 你必须实施清理

### 5.5.3 终结条件

```java
public class TerminationCondition {
    public static void main(String[] args) {
        Book novel = new Book(true);
        // Proper cleanup:
        novel.checkIn();
        // Drop the reference, forget to clean up:
        new Book(true);
        // Force garbage collection & finalization:
        System.gc();
    }
}
class Book {
    boolean checkedOut = false;
    Book(boolean checkOut) {
        checkedOut = checkOut;
    }
    void checkIn() {
        checkedOut = false;
    }
    protected void finalize() {
        if(checkedOut)
            System.out.println("Error: checked out");
        // Normally, you'll also do this:
        // super.finalize(); // Call the base-class version
    }
}
```

### 5.5.4 垃圾回收器如何工作

①垃圾回收器对于提高对象的创建速度，具有明显的效果。

②在某些Java虚拟机中，堆的实现就像一个传动带，每分配一个对象，它就往前移动一格，这就意味着对象存储空间的分配速度很快。

③Java的垃圾回收器所依据的思想：对任何“活”的对象，一定能最终追溯到其存活在堆栈活静态存储区之中的引用。由此，如果从堆栈和静态存储区开始，遍历所有的引用，就能找到所有“活”的对象。

④Java虚拟机采用一种自适应的垃圾回收技术，包括停止——复制和标记——清扫两种工作模式。

⑤停止——复制：先暂停程序的运行，然后将所有存活的对象从当前堆复制到另一个堆，没有被复制的就是垃圾。当对象被复制时，它们是一个挨一个的，所以新堆保持紧凑排列。

⑥标记——清扫：从堆栈和静态存储区出发，遍历所有引用，进而找出所有存活的对象，每当它找到一个存活对象，就会给对象设一个标记，这个过程中不会回收任何对象。只有当全部标记工作完成的时候，清理动作才会开始。在清理过程中，没有标记的对象会被释放，不会发生复制动作。所以剩下的堆空间是不连续的。

⑦Java虚拟机会进行监视，如果所有对象都很稳定，垃圾回收器的效率降低的话，就切换到标记——清扫模式，同样，Java虚拟机会跟踪标记——清扫的效果，要是堆空间出现很多碎片，就会切换为停止——复制模式。



-------------------------------------------------------------------2018 11.04 晚上10:33---------------------------------------------------------------